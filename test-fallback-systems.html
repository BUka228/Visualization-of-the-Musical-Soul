<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Galaxy Fallback Systems Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 800px;
            height: 600px;
            border: 1px solid #333;
            margin: 20px 0;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        button {
            padding: 10px 15px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            cursor: pointer;
            border-radius: 4px;
        }
        
        button:hover {
            background: #555;
        }
        
        button.active {
            background: #0066cc;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .info-section {
            background: #111;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
        }
        
        .info-section h3 {
            margin-top: 0;
            color: #60a5fa;
        }
        
        .stats {
            font-family: monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .performance-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .performance-high { background: #10b981; }
        .performance-medium { background: #f59e0b; }
        .performance-low { background: #ef4444; }
        
        .texture-preview {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .texture-item {
            text-align: center;
            font-size: 11px;
        }
        
        .texture-item canvas {
            border: 1px solid #333;
            display: block;
            margin-bottom: 5px;
        }
        
        .geometry-preview {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .geometry-item {
            text-align: center;
            font-size: 11px;
            width: 120px;
        }
        
        .geometry-item canvas {
            border: 1px solid #333;
            display: block;
            margin-bottom: 5px;
            width: 120px;
            height: 90px;
        }
    </style>
</head>
<body>
    <h1>ðŸŒŒ Soul Galaxy Fallback Systems Test</h1>
    
    <div class="info-panel">
        <div class="info-section">
            <h3>Device Performance</h3>
            <div id="device-info" class="stats">Loading...</div>
        </div>
        
        <div class="info-section">
            <h3>System Statistics</h3>
            <div id="system-stats" class="stats">Loading...</div>
        </div>
    </div>
    
    <div id="container"></div>
    
    <div class="controls">
        <button onclick="testTextureGeneration()">Test Texture Generation</button>
        <button onclick="testGeometryGeneration()">Test Geometry Generation</button>
        <button onclick="testPerformanceAdjustment()">Test Performance Adjustment</button>
        <button onclick="simulateTextureError()">Simulate Texture Error</button>
        <button onclick="simulateGeometryError()">Simulate Geometry Error</button>
        <button onclick="runBenchmark()">Run Benchmark</button>
        <button onclick="toggleQuality()">Toggle Quality</button>
        <button onclick="clearCaches()">Clear Caches</button>
    </div>
    
    <div class="info-panel">
        <div class="info-section">
            <h3>Procedural Textures</h3>
            <div id="texture-previews" class="texture-preview">
                <!-- Texture previews will be added here -->
            </div>
        </div>
        
        <div class="info-section">
            <h3>Geometry Complexity</h3>
            <div id="geometry-previews" class="geometry-preview">
                <!-- Geometry previews will be added here -->
            </div>
        </div>
    </div>
    
    <div class="info-section">
        <h3>Performance Report</h3>
        <pre id="performance-report" style="font-size: 11px; line-height: 1.3; white-space: pre-wrap;">Loading...</pre>
    </div>

    <script type="module">
        import * as THREE from './node_modules/three/build/three.module.js';
        
        // Mock the Soul Galaxy fallback systems for testing
        class MockFallbackSystem {
            constructor() {
                this.devicePerformance = this.detectDevicePerformance();
                this.textureCache = new Map();
                this.geometryCache = new Map();
                this.currentQuality = this.devicePerformance.level;
                this.setupScene();
                this.updateDisplays();
            }
            
            detectDevicePerformance() {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                
                let score = 0;
                let level = 'low';
                
                if (gl) {
                    // WebGL version
                    if (canvas.getContext('webgl2')) score += 20;
                    else score += 10;
                    
                    // Capabilities
                    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                    if (maxTextureSize >= 4096) score += 15;
                    else if (maxTextureSize >= 2048) score += 10;
                    
                    // Extensions
                    const extensions = gl.getSupportedExtensions() || [];
                    score += Math.min(extensions.length, 20);
                    
                    // Hardware detection
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL).toLowerCase();
                        if (renderer.includes('nvidia') || renderer.includes('amd')) score += 15;
                        else if (renderer.includes('intel')) score += 5;
                    }
                }
                
                // Memory
                if (navigator.deviceMemory) {
                    if (navigator.deviceMemory >= 8) score += 10;
                    else if (navigator.deviceMemory >= 4) score += 5;
                }
                
                // CPU cores
                if (navigator.hardwareConcurrency >= 8) score += 10;
                else if (navigator.hardwareConcurrency >= 4) score += 5;
                
                // Mobile penalty
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) score -= 20;
                
                if (score >= 60) level = 'high';
                else if (score >= 35) level = 'medium';
                
                return {
                    level,
                    score,
                    capabilities: {
                        webgl2: !!canvas.getContext('webgl2'),
                        maxTextureSize: gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 0,
                        extensions: gl ? gl.getSupportedExtensions().length : 0,
                        memory: navigator.deviceMemory || 'unknown',
                        cores: navigator.hardwareConcurrency || 'unknown',
                        isMobile
                    }
                };
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, 800/600, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: this.currentQuality !== 'low' });
                this.renderer.setSize(800, 600);
                this.renderer.setClearColor(0x000011);
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                this.camera.position.z = 5;
                
                // Add some test objects
                this.testObjects = [];
                this.animate();
            }
            
            createProceduralTexture(type, genre = 'default', energy = 0.5) {
                const size = this.getTextureSizeForQuality();
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Genre colors
                const genreColors = {
                    metal: ['#FF0040', '#800020'],
                    rock: ['#0080FF', '#004080'],
                    punk: ['#00FF40', '#008020'],
                    electronic: ['#8000FF', '#400080'],
                    jazz: ['#FFD700', '#806800'],
                    default: ['#FFFFFF', '#808080']
                };
                
                const colors = genreColors[genre] || genreColors.default;
                
                // Create gradient
                const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                gradient.addColorStop(0, colors[0]);
                gradient.addColorStop(1, colors[1]);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                
                // Add pattern based on type
                if (type === 'genre_based') {
                    this.addGenrePattern(ctx, size, genre, energy);
                } else if (type === 'energy_based') {
                    this.addEnergyPattern(ctx, size, energy);
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                
                return { texture, canvas };
            }
            
            addGenrePattern(ctx, size, genre, energy) {
                ctx.globalCompositeOperation = 'overlay';
                
                switch (genre) {
                    case 'metal':
                        // Sharp lines
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 * i) / 20;
                            const length = size * energy * 0.4;
                            ctx.strokeStyle = `rgba(255, 255, 255, ${energy * 0.3})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(size/2, size/2);
                            ctx.lineTo(
                                size/2 + Math.cos(angle) * length,
                                size/2 + Math.sin(angle) * length
                            );
                            ctx.stroke();
                        }
                        break;
                    
                    case 'electronic':
                        // Circuit pattern
                        const gridSize = 8;
                        const cellSize = size / gridSize;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${energy * 0.4})`;
                        ctx.lineWidth = 1;
                        
                        for (let x = 0; x < gridSize; x++) {
                            for (let y = 0; y < gridSize; y++) {
                                if (Math.random() < energy) {
                                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                                }
                            }
                        }
                        break;
                    
                    default:
                        // Noise pattern
                        for (let i = 0; i < size * energy * 0.5; i++) {
                            const x = Math.random() * size;
                            const y = Math.random() * size;
                            const radius = Math.random() * 3;
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * energy * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                }
                
                ctx.globalCompositeOperation = 'source-over';
            }
            
            addEnergyPattern(ctx, size, energy) {
                const numEffects = Math.floor(energy * 50);
                for (let i = 0; i < numEffects; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const radius = Math.random() * energy * 20;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * energy * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            createGeometry(type, complexity = 'medium') {
                const complexityLevels = {
                    low: { subdivisions: 0, detail: 1 },
                    medium: { subdivisions: 1, detail: 2 },
                    high: { subdivisions: 2, detail: 3 }
                };
                
                const level = complexityLevels[complexity] || complexityLevels.medium;
                
                switch (type) {
                    case 'crystal':
                        if (complexity === 'low') {
                            return new THREE.OctahedronGeometry(1, 0);
                        } else {
                            return new THREE.IcosahedronGeometry(1, level.subdivisions);
                        }
                    
                    case 'nebula':
                        const segments = level.detail * 4;
                        return new THREE.PlaneGeometry(5, 5, segments, segments);
                    
                    case 'particle':
                        const particleCount = level.detail * 50;
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array(particleCount * 3);
                        
                        for (let i = 0; i < particleCount; i++) {
                            positions[i * 3] = (Math.random() - 0.5) * 10;
                            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                        }
                        
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        return geometry;
                    
                    default:
                        return new THREE.BoxGeometry(1, 1, 1);
                }
            }
            
            getTextureSizeForQuality() {
                switch (this.currentQuality) {
                    case 'high': return 512;
                    case 'medium': return 256;
                    case 'low': return 128;
                    default: return 256;
                }
            }
            
            getGeometryComplexityForQuality() {
                switch (this.currentQuality) {
                    case 'high': return 'high';
                    case 'medium': return 'medium';
                    case 'low': return 'low';
                    default: return 'medium';
                }
            }
            
            updateDisplays() {
                // Update device info
                const deviceInfo = document.getElementById('device-info');
                const perf = this.devicePerformance;
                const indicator = `<span class="performance-indicator performance-${perf.level}"></span>`;
                
                deviceInfo.innerHTML = `
                    ${indicator}Performance Level: ${perf.level.toUpperCase()}<br>
                    Score: ${perf.score}/100<br>
                    WebGL 2.0: ${perf.capabilities.webgl2 ? 'Yes' : 'No'}<br>
                    Max Texture Size: ${perf.capabilities.maxTextureSize}px<br>
                    Extensions: ${perf.capabilities.extensions}<br>
                    Memory: ${perf.capabilities.memory}GB<br>
                    CPU Cores: ${perf.capabilities.cores}<br>
                    Mobile: ${perf.capabilities.isMobile ? 'Yes' : 'No'}
                `;
                
                // Update system stats
                const systemStats = document.getElementById('system-stats');
                systemStats.innerHTML = `
                    Current Quality: ${this.currentQuality.toUpperCase()}<br>
                    Texture Size: ${this.getTextureSizeForQuality()}px<br>
                    Geometry Complexity: ${this.getGeometryComplexityForQuality()}<br>
                    Texture Cache: ${this.textureCache.size} items<br>
                    Geometry Cache: ${this.geometryCache.size} items<br>
                    Scene Objects: ${this.testObjects.length}
                `;
                
                // Update performance report
                this.updatePerformanceReport();
            }
            
            updatePerformanceReport() {
                const report = document.getElementById('performance-report');
                const perf = this.devicePerformance;
                
                report.textContent = `
Soul Galaxy Fallback Systems Test Report
=======================================

Device Performance Level: ${perf.level.toUpperCase()}
Performance Score: ${perf.score}/100

WebGL Capabilities:
- Version: ${perf.capabilities.webgl2 ? '2.0' : '1.0'}
- Max Texture Size: ${perf.capabilities.maxTextureSize}px
- Extensions: ${perf.capabilities.extensions} supported

Hardware:
- CPU Cores: ${perf.capabilities.cores}
- Memory: ${perf.capabilities.memory}GB
- Mobile: ${perf.capabilities.isMobile ? 'Yes' : 'No'}

Quality Settings Applied:
- Texture Max Size: ${this.getTextureSizeForQuality()}px
- Geometry Complexity: ${this.getGeometryComplexityForQuality()}
- Current Quality Level: ${this.currentQuality}

Cache Statistics:
- Texture Cache: ${this.textureCache.size} items
- Geometry Cache: ${this.geometryCache.size} items

Recommendations:
${this.getRecommendations().map(rec => `- ${rec}`).join('\n')}
                `.trim();
            }
            
            getRecommendations() {
                const recommendations = [];
                const perf = this.devicePerformance;
                
                if (perf.level === 'low') {
                    recommendations.push('Consider closing other browser tabs');
                    recommendations.push('Disable browser extensions that might affect performance');
                    if (perf.capabilities.isMobile) {
                        recommendations.push('Close other apps running in the background');
                    }
                }
                
                if (!perf.capabilities.webgl2) {
                    recommendations.push('Update your browser for WebGL 2.0 support');
                }
                
                if (perf.capabilities.maxTextureSize < 2048) {
                    recommendations.push('Update your graphics drivers');
                }
                
                if (recommendations.length === 0) {
                    recommendations.push('Your device is well-optimized for Soul Galaxy');
                }
                
                return recommendations;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Animate test objects
                this.testObjects.forEach((obj, index) => {
                    obj.rotation.x += 0.01 * (index + 1);
                    obj.rotation.y += 0.01 * (index + 1);
                });
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the mock system
        const fallbackSystem = new MockFallbackSystem();
        
        // Make functions available globally
        window.testTextureGeneration = () => {
            const genres = ['metal', 'rock', 'punk', 'electronic', 'jazz'];
            const types = ['genre_based', 'energy_based'];
            const container = document.getElementById('texture-previews');
            container.innerHTML = '';
            
            genres.forEach(genre => {
                const energy = Math.random();
                const result = fallbackSystem.createProceduralTexture('genre_based', genre, energy);
                
                const item = document.createElement('div');
                item.className = 'texture-item';
                item.innerHTML = `
                    <canvas width="64" height="64"></canvas>
                    <div>${genre}</div>
                    <div>Energy: ${energy.toFixed(2)}</div>
                `;
                
                const canvas = item.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                ctx.drawImage(result.canvas, 0, 0, 64, 64);
                
                container.appendChild(item);
            });
            
            fallbackSystem.updateDisplays();
        };
        
        window.testGeometryGeneration = () => {
            const types = ['crystal', 'nebula', 'particle'];
            const complexities = ['low', 'medium', 'high'];
            const container = document.getElementById('geometry-previews');
            container.innerHTML = '';
            
            // Clear existing test objects
            fallbackSystem.testObjects.forEach(obj => {
                fallbackSystem.scene.remove(obj);
            });
            fallbackSystem.testObjects = [];
            
            types.forEach(type => {
                complexities.forEach(complexity => {
                    const geometry = fallbackSystem.createGeometry(type, complexity);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x4080ff, 
                        wireframe: true 
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Position meshes
                    const index = fallbackSystem.testObjects.length;
                    mesh.position.set(
                        (index % 3 - 1) * 3,
                        Math.floor(index / 3) * 3 - 3,
                        0
                    );
                    
                    fallbackSystem.scene.add(mesh);
                    fallbackSystem.testObjects.push(mesh);
                    
                    // Create preview
                    const item = document.createElement('div');
                    item.className = 'geometry-item';
                    item.innerHTML = `
                        <canvas width="120" height="90"></canvas>
                        <div>${type}</div>
                        <div>${complexity}</div>
                        <div>${geometry.attributes.position.count} vertices</div>
                    `;
                    
                    // Render preview
                    const canvas = item.querySelector('canvas');
                    const previewRenderer = new THREE.WebGLRenderer({ canvas, antialias: false });
                    previewRenderer.setSize(120, 90);
                    previewRenderer.setClearColor(0x000011);
                    
                    const previewScene = new THREE.Scene();
                    const previewCamera = new THREE.PerspectiveCamera(75, 120/90, 0.1, 1000);
                    previewCamera.position.z = 3;
                    
                    const previewMesh = new THREE.Mesh(geometry.clone(), material.clone());
                    previewScene.add(previewMesh);
                    
                    previewRenderer.render(previewScene, previewCamera);
                    
                    container.appendChild(item);
                });
            });
            
            fallbackSystem.updateDisplays();
        };
        
        window.testPerformanceAdjustment = () => {
            // Simulate performance adjustment
            const currentFPS = 20 + Math.random() * 40; // Random FPS between 20-60
            
            if (currentFPS < 30) {
                // Reduce quality
                if (fallbackSystem.currentQuality === 'high') {
                    fallbackSystem.currentQuality = 'medium';
                } else if (fallbackSystem.currentQuality === 'medium') {
                    fallbackSystem.currentQuality = 'low';
                }
                console.log(`Performance adjustment: Reduced quality to ${fallbackSystem.currentQuality} (FPS: ${currentFPS.toFixed(1)})`);
            } else if (currentFPS > 50) {
                // Increase quality
                if (fallbackSystem.currentQuality === 'low') {
                    fallbackSystem.currentQuality = 'medium';
                } else if (fallbackSystem.currentQuality === 'medium') {
                    fallbackSystem.currentQuality = 'high';
                }
                console.log(`Performance adjustment: Increased quality to ${fallbackSystem.currentQuality} (FPS: ${currentFPS.toFixed(1)})`);
            }
            
            fallbackSystem.updateDisplays();
        };
        
        window.simulateTextureError = () => {
            console.warn('Simulating texture loading error...');
            const fallbackTexture = fallbackSystem.createProceduralTexture('genre_based', 'metal', 0.8);
            console.log('Created fallback texture:', fallbackTexture);
            
            // Show notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(239, 68, 68, 0.9);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                z-index: 10000;
            `;
            notification.textContent = 'Texture loading failed. Using procedural fallback.';
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), 3000);
        };
        
        window.simulateGeometryError = () => {
            console.warn('Simulating geometry generation error...');
            const fallbackGeometry = fallbackSystem.createGeometry('crystal', 'low');
            console.log('Created fallback geometry:', fallbackGeometry);
            
            // Show notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(239, 68, 68, 0.9);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                z-index: 10000;
            `;
            notification.textContent = 'Geometry generation failed. Using simplified fallback.';
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), 3000);
        };
        
        window.runBenchmark = async () => {
            console.log('Running performance benchmark...');
            
            const startTime = performance.now();
            let frameCount = 0;
            const maxFrames = 120;
            
            // Add more complex objects for benchmarking
            const benchmarkObjects = [];
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.IcosahedronGeometry(0.5, 2);
                const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                fallbackSystem.scene.add(mesh);
                benchmarkObjects.push(mesh);
            }
            
            const benchmarkLoop = () => {
                // Animate objects
                benchmarkObjects.forEach(obj => {
                    obj.rotation.x += 0.02;
                    obj.rotation.y += 0.02;
                });
                
                fallbackSystem.renderer.render(fallbackSystem.scene, fallbackSystem.camera);
                frameCount++;
                
                if (frameCount < maxFrames) {
                    requestAnimationFrame(benchmarkLoop);
                } else {
                    const endTime = performance.now();
                    const totalTime = endTime - startTime;
                    const avgFPS = (frameCount / totalTime) * 1000;
                    
                    console.log(`Benchmark complete: ${avgFPS.toFixed(1)} FPS`);
                    
                    // Cleanup
                    benchmarkObjects.forEach(obj => {
                        fallbackSystem.scene.remove(obj);
                        obj.geometry.dispose();
                        obj.material.dispose();
                    });
                    
                    // Show result
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: rgba(59, 130, 246, 0.9);
                        color: white;
                        padding: 12px 16px;
                        border-radius: 8px;
                        z-index: 10000;
                    `;
                    notification.textContent = `Benchmark: ${avgFPS.toFixed(1)} FPS`;
                    document.body.appendChild(notification);
                    
                    setTimeout(() => notification.remove(), 5000);
                }
            };
            
            requestAnimationFrame(benchmarkLoop);
        };
        
        window.toggleQuality = () => {
            const qualities = ['low', 'medium', 'high'];
            const currentIndex = qualities.indexOf(fallbackSystem.currentQuality);
            const nextIndex = (currentIndex + 1) % qualities.length;
            fallbackSystem.currentQuality = qualities[nextIndex];
            
            console.log(`Quality changed to: ${fallbackSystem.currentQuality}`);
            fallbackSystem.updateDisplays();
        };
        
        window.clearCaches = () => {
            fallbackSystem.textureCache.clear();
            fallbackSystem.geometryCache.clear();
            console.log('Caches cleared');
            fallbackSystem.updateDisplays();
        };
        
        // Initialize with some test data
        setTimeout(() => {
            testTextureGeneration();
            testGeometryGeneration();
        }, 1000);
        
        console.log('Soul Galaxy Fallback Systems Test initialized');
        console.log('Device performance level:', fallbackSystem.devicePerformance.level);
    </script>
</body>
</html>