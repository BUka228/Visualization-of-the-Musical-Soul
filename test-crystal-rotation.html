<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Rotation System Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .control-group button {
            background: #0080ff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        
        .control-group button:hover {
            background: #0066cc;
        }
        
        .control-group button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .control-group input[type="range"] {
            width: 200px;
        }
        
        .control-group input[type="number"] {
            width: 80px;
            padding: 4px;
            background: #333;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            font-size: 12px;
            max-width: 300px;
        }
        
        .info-item {
            margin-bottom: 5px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-active {
            background: #00ff00;
        }
        
        .status-inactive {
            background: #666;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            max-width: 250px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>Crystal Rotation Test</h3>
            
            <div class="control-group">
                <label>Crystal Actions:</label>
                <button id="startRotation">Start Rotation</button>
                <button id="stopRotation">Stop Rotation</button>
                <button id="pauseRotation">Pause</button>
                <button id="resumeRotation">Resume</button>
            </div>
            
            <div class="control-group">
                <label>Rotation Speed: <span id="speedValue">1.0</span>x</label>
                <input type="range" id="speedSlider" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label>Popularity Override:</label>
                <input type="number" id="popularityInput" min="0" max="100" placeholder="Popularity">
                <button id="applyPopularity">Apply Popularity</button>
            </div>
            
            <div class="control-group">
                <label>Genre Test:</label>
                <select id="genreSelect">
                    <option value="metal">Metal</option>
                    <option value="rock">Rock</option>
                    <option value="punk">Punk</option>
                    <option value="electronic">Electronic</option>
                    <option value="jazz">Jazz</option>
                    <option value="classical">Classical</option>
                    <option value="pop">Pop</option>
                    <option value="indie">Indie</option>
                    <option value="hiphop">Hip-Hop</option>
                </select>
                <button id="applyGenre">Apply Genre</button>
            </div>
            
            <div class="control-group">
                <button id="resetRotation">Reset to Original</button>
                <button id="randomizeRotation">Randomize</button>
            </div>
        </div>
        
        <div id="info">
            <h4>Rotation Status</h4>
            <div class="info-item">
                <span class="status-indicator" id="rotationStatus"></span>
                <span id="rotationStatusText">Inactive</span>
            </div>
            <div class="info-item">Speed: <span id="currentSpeed">0.0</span> rad/s</div>
            <div class="info-item">Popularity: <span id="currentPopularity">N/A</span></div>
            <div class="info-item">Genre: <span id="currentGenre">pop</span></div>
            <div class="info-item">Transition: <span id="transitionStatus">None</span></div>
            <div class="info-item">Active Rotations: <span id="activeRotations">0</span></div>
        </div>
        
        <div id="instructions">
            <h4>Instructions</h4>
            <p>• Click "Start Rotation" to begin crystal rotation</p>
            <p>• Adjust speed with the slider</p>
            <p>• Test different popularity values (0-100)</p>
            <p>• Try different genres to see speed variations</p>
            <p>• Use pause/resume to test transitions</p>
            <p>• Click the crystal to focus and start audio playback</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from './node_modules/three/build/three.module.js';
        import { CrystalRotationSystem } from './dist/soul-galaxy/effects/CrystalRotationSystem.js';
        import { CrystalShaderMaterial } from './dist/soul-galaxy/materials/CrystalShaderMaterial.js';

        class CrystalRotationTest {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.rotationSystem = new CrystalRotationSystem();
                
                this.testCrystal = null;
                this.testMesh = null;
                this.testTrack = null;
                
                this.init();
                this.setupControls();
                this.animate();
            }
            
            init() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000011);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // Setup camera
                this.camera.position.set(0, 0, 15);
                this.camera.lookAt(0, 0, 0);
                
                // Create test crystal
                this.createTestCrystal();
                
                // Add lighting
                this.setupLighting();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                console.log('🧪 Crystal Rotation Test initialized');
            }
            
            createTestCrystal() {
                // Create test track data
                this.testTrack = {
                    id: 'test-crystal-1',
                    name: 'Test Crystal Song',
                    artist: 'Test Artist',
                    album: 'Test Album',
                    genre: 'pop',
                    popularity: 75,
                    duration: 210, // 3.5 minutes
                    previewUrl: null,
                    imageUrl: null,
                    color: '#FF0080',
                    size: 1.0,
                    position: { x: 0, y: 0, z: 0 }
                };
                
                // Create crystal geometry (simple for testing)
                const geometry = new THREE.IcosahedronGeometry(2, 1);
                
                // Create crystal material
                const material = CrystalShaderMaterial.createForGenre(this.testTrack.genre, {
                    emissiveIntensity: 0.5,
                    pulseAmplitude: 0.3,
                    pulseSpeed: 1.5
                });
                
                // Create mesh
                this.testMesh = new THREE.Mesh(geometry, material);
                this.testMesh.position.set(0, 0, 0);
                this.testMesh.castShadow = true;
                this.testMesh.receiveShadow = true;
                
                // Add metadata
                this.testMesh.userData = {
                    trackId: this.testTrack.id,
                    trackName: this.testTrack.name,
                    artist: this.testTrack.artist,
                    genre: this.testTrack.genre,
                    isCrystal: true
                };
                
                this.scene.add(this.testMesh);
                
                console.log('🔮 Test crystal created');
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);
                
                // Directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Point lights for crystal illumination
                const pointLight1 = new THREE.PointLight(0x00ffff, 0.5, 50);
                pointLight1.position.set(-10, 0, 10);
                this.scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 50);
                pointLight2.position.set(10, 0, 10);
                this.scene.add(pointLight2);
            }
            
            setupControls() {
                // Start rotation button
                document.getElementById('startRotation').addEventListener('click', () => {
                    this.rotationSystem.startRotation(this.testTrack, this.testMesh);
                    this.updateUI();
                });
                
                // Stop rotation button
                document.getElementById('stopRotation').addEventListener('click', () => {
                    this.rotationSystem.stopRotation(this.testTrack.id);
                    this.updateUI();
                });
                
                // Pause rotation button
                document.getElementById('pauseRotation').addEventListener('click', () => {
                    this.rotationSystem.pauseRotation(this.testTrack.id);
                    this.updateUI();
                });
                
                // Resume rotation button
                document.getElementById('resumeRotation').addEventListener('click', () => {
                    this.rotationSystem.resumeRotation(this.testTrack.id);
                    this.updateUI();
                });
                
                // Speed slider
                const speedSlider = document.getElementById('speedSlider');
                speedSlider.addEventListener('input', (e) => {
                    const multiplier = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = multiplier.toFixed(1);
                    this.rotationSystem.adjustRotationSpeed(this.testTrack.id, multiplier);
                    this.updateUI();
                });
                
                // Popularity input
                document.getElementById('applyPopularity').addEventListener('click', () => {
                    const popularityInput = document.getElementById('popularityInput');
                    const popularity = parseInt(popularityInput.value);
                    if (popularity >= 0 && popularity <= 100) {
                        this.testTrack.popularity = popularity;
                        // Restart rotation with new popularity
                        if (this.rotationSystem.isRotating(this.testTrack.id)) {
                            this.rotationSystem.stopRotation(this.testTrack.id);
                            setTimeout(() => {
                                this.rotationSystem.startRotation(this.testTrack, this.testMesh);
                                this.updateUI();
                            }, 100);
                        }
                        this.updateUI();
                    }
                });
                
                // Genre selection
                document.getElementById('applyGenre').addEventListener('click', () => {
                    const genreSelect = document.getElementById('genreSelect');
                    const newGenre = genreSelect.value;
                    this.testTrack.genre = newGenre;
                    
                    // Update material
                    const newMaterial = CrystalShaderMaterial.createForGenre(newGenre, {
                        emissiveIntensity: 0.5,
                        pulseAmplitude: 0.3,
                        pulseSpeed: 1.5
                    });
                    this.testMesh.material.dispose();
                    this.testMesh.material = newMaterial;
                    
                    // Restart rotation with new genre
                    if (this.rotationSystem.isRotating(this.testTrack.id)) {
                        this.rotationSystem.stopRotation(this.testTrack.id);
                        setTimeout(() => {
                            this.rotationSystem.startRotation(this.testTrack, this.testMesh);
                            this.updateUI();
                        }, 100);
                    }
                    this.updateUI();
                });
                
                // Reset rotation button
                document.getElementById('resetRotation').addEventListener('click', () => {
                    this.rotationSystem.stopRotation(this.testTrack.id);
                    this.testMesh.rotation.set(0, 0, 0);
                    this.updateUI();
                });
                
                // Randomize rotation button
                document.getElementById('randomizeRotation').addEventListener('click', () => {
                    this.testTrack.popularity = Math.floor(Math.random() * 100); // 0-100 popularity
                    this.testTrack.duration = Math.floor(Math.random() * 240) + 120; // 2-6 minutes
                    
                    const genres = ['metal', 'rock', 'punk', 'electronic', 'jazz', 'classical', 'pop', 'indie', 'hiphop'];
                    this.testTrack.genre = genres[Math.floor(Math.random() * genres.length)];
                    
                    // Update UI
                    document.getElementById('popularityInput').value = this.testTrack.popularity;
                    document.getElementById('genreSelect').value = this.testTrack.genre;
                    
                    // Update material
                    const newMaterial = CrystalShaderMaterial.createForGenre(this.testTrack.genre, {
                        emissiveIntensity: 0.5,
                        pulseAmplitude: 0.3,
                        pulseSpeed: 1.5
                    });
                    this.testMesh.material.dispose();
                    this.testMesh.material = newMaterial;
                    
                    // Restart rotation
                    if (this.rotationSystem.isRotating(this.testTrack.id)) {
                        this.rotationSystem.stopRotation(this.testTrack.id);
                        setTimeout(() => {
                            this.rotationSystem.startRotation(this.testTrack, this.testMesh);
                            this.updateUI();
                        }, 100);
                    }
                    this.updateUI();
                });
                
                // Click on crystal to simulate focus
                this.renderer.domElement.addEventListener('click', (event) => {
                    const mouse = new THREE.Vector2();
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, this.camera);
                    
                    const intersects = raycaster.intersectObject(this.testMesh);
                    if (intersects.length > 0) {
                        console.log('🎯 Crystal clicked - simulating focus and playback');
                        
                        // Simulate focus and playback
                        if (!this.rotationSystem.isRotating(this.testTrack.id)) {
                            this.rotationSystem.startRotation(this.testTrack, this.testMesh);
                            this.updateUI();
                        }
                    }
                });
            }
            
            updateUI() {
                const isRotating = this.rotationSystem.isRotating(this.testTrack.id);
                const stats = this.rotationSystem.getRotationStats();
                const currentSpeed = this.rotationSystem.getCurrentRotationSpeed(this.testTrack.id);
                
                // Update status indicator
                const statusIndicator = document.getElementById('rotationStatus');
                const statusText = document.getElementById('rotationStatusText');
                
                if (isRotating) {
                    statusIndicator.className = 'status-indicator status-active';
                    statusText.textContent = 'Active';
                } else {
                    statusIndicator.className = 'status-indicator status-inactive';
                    statusText.textContent = 'Inactive';
                }
                
                // Update info
                document.getElementById('currentSpeed').textContent = 
                    currentSpeed ? currentSpeed.length().toFixed(3) : '0.000';
                document.getElementById('currentPopularity').textContent = 
                    this.testTrack.popularity || 'N/A';
                document.getElementById('currentGenre').textContent = 
                    this.testTrack.genre;
                document.getElementById('activeRotations').textContent = 
                    stats.activeRotations;
                
                // Update button states
                document.getElementById('startRotation').disabled = isRotating;
                document.getElementById('stopRotation').disabled = !isRotating;
                document.getElementById('pauseRotation').disabled = !isRotating;
                document.getElementById('resumeRotation').disabled = !isRotating;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update material time for shader animation
                if (this.testMesh && this.testMesh.material.updateTime) {
                    this.testMesh.material.updateTime(performance.now() * 0.001);
                }
                
                // Update camera position for fresnel calculations
                if (this.testMesh && this.testMesh.material.updateCameraPosition) {
                    this.testMesh.material.updateCameraPosition(this.camera.position);
                }
                
                // Update UI periodically
                if (Math.floor(performance.now() / 100) % 5 === 0) {
                    this.updateUI();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            dispose() {
                this.rotationSystem.dispose();
                this.renderer.dispose();
                console.log('🗑️ Crystal Rotation Test disposed');
            }
        }

        // Initialize test when page loads
        window.addEventListener('load', () => {
            const test = new CrystalRotationTest();
            
            // Handle page unload
            window.addEventListener('beforeunload', () => {
                test.dispose();
            });
        });
    </script>
</body>
</html>