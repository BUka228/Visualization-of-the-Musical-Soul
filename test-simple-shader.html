<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Shader Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100%;
            height: 400px;
            border: 1px solid #333;
        }
        #info {
            margin-top: 10px;
            padding: 10px;
            background: #111;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Simple Shader Test</h1>
    <div id="container"></div>
    <div id="info">
        <div id="status">Testing...</div>
        <div id="errors"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // Simple test vertex shader
        const testVertexShader = `
            precision mediump float;
            
            attribute vec3 position;
            attribute vec3 normal;
            attribute vec2 uv;
            
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat3 normalMatrix;
            
            varying vec3 vNormal;
            varying vec2 vUv;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Simple test fragment shader
        const testFragmentShader = `
            precision mediump float;
            
            uniform vec3 color;
            
            varying vec3 vNormal;
            varying vec2 vUv;
            
            void main() {
                vec3 light = normalize(vec3(1.0, 1.0, 1.0));
                float intensity = max(0.0, dot(vNormal, light));
                vec3 finalColor = color * (0.3 + intensity * 0.7);
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        let scene, camera, renderer;
        let statusDiv, errorsDiv;

        function init() {
            statusDiv = document.getElementById('status');
            errorsDiv = document.getElementById('errors');

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            
            const container = document.getElementById('container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x000011);
            container.appendChild(renderer.domElement);

            camera.position.set(0, 0, 5);

            statusDiv.textContent = 'Scene initialized';
        }

        function testSimpleShader() {
            try {
                // Create simple material
                const material = new THREE.ShaderMaterial({
                    vertexShader: testVertexShader,
                    fragmentShader: testFragmentShader,
                    uniforms: {
                        color: { value: new THREE.Color(0xFF0030) }
                    }
                });

                // Create geometry
                const geometry = new THREE.IcosahedronGeometry(1, 1);
                
                // Create mesh
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                // Try to render
                renderer.render(scene, camera);

                statusDiv.textContent = '✅ Simple shader test passed';

                // Now test with custom attributes
                testCustomAttributes();

            } catch (error) {
                statusDiv.textContent = '❌ Simple shader test failed';
                errorsDiv.textContent = error.message;
                console.error('Simple shader error:', error);
            }
        }

        function testCustomAttributes() {
            try {
                // Vertex shader with custom attributes
                const customVertexShader = `
                    precision mediump float;
                    
                    attribute vec3 position;
                    attribute vec3 normal;
                    attribute vec2 uv;
                    attribute vec3 originalPosition;
                    attribute float pulsePhase;
                    attribute float bpmMultiplier;
                    attribute vec3 facetNormal;
                    
                    uniform mat4 modelViewMatrix;
                    uniform mat4 projectionMatrix;
                    uniform mat3 normalMatrix;
                    uniform float time;
                    
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying float vPulse;
                    
                    void main() {
                        float pulse = sin(time + pulsePhase) * 0.1;
                        vec3 pos = originalPosition * (1.0 + pulse);
                        
                        vNormal = normalize(normalMatrix * normal);
                        vUv = uv;
                        vPulse = pulse;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `;

                const customFragmentShader = `
                    precision mediump float;
                    
                    uniform vec3 color;
                    uniform float time;
                    
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying float vPulse;
                    
                    void main() {
                        vec3 light = normalize(vec3(1.0, 1.0, 1.0));
                        float intensity = max(0.0, dot(vNormal, light));
                        vec3 finalColor = color * (0.5 + intensity * 0.5 + vPulse);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `;

                // Create geometry with custom attributes
                const geometry = new THREE.IcosahedronGeometry(1, 1);
                
                // Add custom attributes
                const positionAttribute = geometry.attributes.position;
                const vertexCount = positionAttribute.count;
                
                // Original positions
                const originalPositions = new Float32Array(vertexCount * 3);
                originalPositions.set(positionAttribute.array);
                geometry.setAttribute('originalPosition', new THREE.BufferAttribute(originalPositions, 3));
                
                // Pulse phases
                const pulsePhases = new Float32Array(vertexCount);
                for (let i = 0; i < vertexCount; i++) {
                    pulsePhases[i] = Math.random() * Math.PI * 2;
                }
                geometry.setAttribute('pulsePhase', new THREE.BufferAttribute(pulsePhases, 1));
                
                // BPM multipliers
                const bpmMultipliers = new Float32Array(vertexCount);
                for (let i = 0; i < vertexCount; i++) {
                    bpmMultipliers[i] = 1.0;
                }
                geometry.setAttribute('bpmMultiplier', new THREE.BufferAttribute(bpmMultipliers, 1));
                
                // Facet normals
                geometry.computeVertexNormals();
                const facetNormals = new Float32Array(vertexCount * 3);
                facetNormals.set(geometry.attributes.normal.array);
                geometry.setAttribute('facetNormal', new THREE.BufferAttribute(facetNormals, 3));

                // Create material
                const material = new THREE.ShaderMaterial({
                    vertexShader: customVertexShader,
                    fragmentShader: customFragmentShader,
                    uniforms: {
                        color: { value: new THREE.Color(0x0080FF) },
                        time: { value: 0.0 }
                    }
                });

                // Create mesh
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.x = 2;
                scene.add(mesh);

                // Try to render
                renderer.render(scene, camera);

                statusDiv.textContent = '✅ Custom attributes test passed';

                // Start animation
                let time = 0;
                function animate() {
                    time += 0.016;
                    material.uniforms.time.value = time;
                    
                    mesh.rotation.x += 0.01;
                    mesh.rotation.y += 0.02;
                    
                    renderer.render(scene, camera);
                    
                    if (time < 5.0) {
                        requestAnimationFrame(animate);
                    }
                }
                animate();

            } catch (error) {
                statusDiv.textContent = '❌ Custom attributes test failed';
                errorsDiv.textContent += '\n' + error.message;
                console.error('Custom attributes error:', error);
            }
        }

        // Initialize and run tests
        init();
        setTimeout(testSimpleShader, 100);

    </script>
</body>
</html>